%% Extract EEG features in time, fequency, and nonlinear domains.

function eeg_features = get_eeg_features(signals,chanlocs,params)

disp('Extracting EEG features...')

fs = params.fs;

% default entropy parameters
m = 2;
r = .15;
n = 2;
tau = 1;
coarseType = 'Standard deviation';
nScales = 20;
filtData = true;

% Time domain
disp('Calculating time-domain EEG features...')
eeg_features.time.mean = mean(signals,2);
eeg_features.time.trimmed_mean = trimmean(signals,20,2);
eeg_features.time.median = median(signals,2);
eeg_features.time.mode = mode(signals,2);
eeg_features.time.var = var(signals,0,2);
eeg_features.time.skewness = skewness(signals,0,2);
eeg_features.time.kurtosis = kurtosis(signals,0,2);
eeg_features.time.iqr = iqr(signals,2);

% Frequency domain
nChan = size(signals,1);
fRange = [1 45];    % WARNING: make sure these are within filtered signal
winSize = 3;        % window size (in s). default = 2 (recommended by Smith et al (2017)
winType = 'hamming';
overlap = 50;       % 50% default (Smith et al. 2017)
ps = parallel.Settings; ps.Pool.AutoCreate = params.parpool; % use parallel computing

% Use Multiple GPUs in Parallel Pool
if params.parpool && params.gpu
    availableGPUs = gpuDeviceCount("available");
    if availableGPUs > 1
        parpool('Processes',availableGPUs);
        fprintf('%g GPUs detected. Using them in parallel pool. \n',availableGPUs)
    else
        fprintf('Only one GPU detected. Using normal GPU and parallel pool computing. \n')
    end
end

% Initiate progressbar (only when not in parpool)
if ~params.parpool
    progressbar('Extracting EEG features on EEG channels')
end

disp('Calculating frequency- and nonlinear domain EEG features...')
for iChan = 1:nChan

    fprintf('EEG channel %g \n', iChan)

    % Compute PSD using pwelch
    [pwr, pwr_dB, freqs] = compute_psd(signals(iChan,:), ...
        fs*winSize,winType,overlap,[],fs,fRange,'psd', false);

    % Delta
    delta = pwr_dB(freqs >= fRange(1) & freqs <= 3);

    % Theta
    theta = pwr_dB(freqs >= 3 & freqs <= 7);

    % Alpha
    alpha= pwr_dB(freqs >= 8 & freqs <= 13);

    % Beta
    beta = pwr_dB(freqs >= 13 & freqs <= 30);

    % Low gamma
    gamma = pwr_dB(freqs >= 31 & freqs <= fRange(2));

    % Entropy
    if size(signals,2) > 5000 % Downsample to accelerate on data with more than 5,000 samples
        new_fs = 90;  % for Nyquist freq = lowpass cutoff (i.e. 45 Hz)
        fac = fs / new_fs; % downsample factor

        % downsample if integer, otherwise decimate to round factor
        if fac ~= floor(fac)
            fac = round(fac);
            signals_res = decimate(signals(iChan,:), fac);
            fprintf('Decimating EEG data to %g Hz sample rate to compute entropy on these large datasets. \n',new_fs)
        else
            signals_res = resample(signals(iChan,:), 1, fac);
            fprintf('Downsampling EEG data to %g Hz sample rate to compute entropy on these large datasets. \n',new_fs)
        end
        % Plot to check
        % times_res = (0:1/new_fs:(length(signals_res(iChan,:))-1)/new_fs)*1000;
        % figure; plot(times(1:fs*5), signals(iChan,1:fs*5)); % plot 5 s of data
        % hold on; plot(times_res(1:new_fs*5), signals_res(iChan,1:new_fs*5));

        % Lowest_freq = 1 / (length(signals(iChan,:))/1000)
        % highest_freq = new_fs / (2*nScales)
        % warning('Lowest frequency captured by MFE after downsampling = %g', )

        % Fuzzy entropy
        % fe = compute_fe(signals_res, m, r, n, tau, params.gpu);

        % Multiscale fuzzy entropy
        % [mfe, scales, scale_bounds] = compute_mfe(signals_res, m, r, tau, coarseType, nScales, filtData, new_fs, n, params.gpu);
        % plot(scales(end:-1:1),mfe(end:-1:1));  hold on; 
        % title('downsampled'); axis tight; box on; grid on
        % xticks(scales); xticklabels(scale_bounds(end:-1:1)); xtickangle(45)

    else

        % Fuzzy entropy
        disp('Computing fuzzy entropy...')
        % fe = compute_fe(signals(iChan,:), m, r, n, tau, params.gpu);
    
        % Multiscale fuzzy entropy
        disp('Computing multiscale fuzzy entropy...')
        % [mfe, scales, scale_bounds] = compute_mfe(signals(iChan,:), m, r, tau, coarseType, nScales, filtData, fs, n, params.gpu);
        % plot(scales(end:-1:1),mfe(end:-1:1)); hold on; axis tight; box on; grid on
        % xticks(scales); xticklabels(scale_bounds(end:-1:1)); xtickangle(45)

    end

    % Outputs
    eeg_features.frequency.pwr(iChan,:) = pwr;
    eeg_features.frequency.pwr_dB(iChan,:) = pwr_dB;
    eeg_features.frequency.freqs(iChan,:) = freqs;
    eeg_features.frequency.delta(iChan,:) = delta;
    eeg_features.frequency.theta(iChan,:) = theta;
    eeg_features.frequency.alpha(iChan,:) = alpha;
    eeg_features.frequency.beta(iChan,:) = beta;
    eeg_features.frequency.low_gamma(iChan,:) = gamma;
    % eeg_features.nonlinear.MFE_scales(iChan,:) = scales;
    % eeg_features.nonlinear.MFE_scale_bounds(iChan,:) = scale_bounds;
    % eeg_features.nonlinear.MFE(iChan,:) = mfe;
    % eeg_features.nonlinear.MFE_mean(iChan,:) = mean(mfe);
    % eeg_features.nonlinear.MFE_sd(iChan,:) = std(mfe);
    % eeg_features.nonlinear.MFE_var(iChan,:) = var(mfe);
    % eeg_features.nonlinear.MFE_area(iChan,:) = trapz(mfe);
    % [~,eeg_features.nonlinear.MFE_peak(iChan,:)] = max(mfe);


    % Individual alpha frequency (IAF) (my code, not working)
    % iaf = detect_iaf(pwr(iChan,:), freqs, winSize, params)

    if ~params.parpool
        progressbar(iChan/nChan)
    end

end

% Shut down parallel pool
% if params.parpool
%     delete(gcp('nocreate'));
% end

% IAF (only export CoG)
disp('Detecting individual alpha frequency (IAF) for each EEG channel...')
[pSum, pChans, f] = restingIAF(signals, size(signals,1), 3, [1 30], fs, [7 13], 11, 5);
eeg_features.frequency.IAF_mean = pSum.cog;
eeg_features.frequency.IAF = [pChans.gravs];


% Asymmetry (use log(pwr) no pwr_dB) - on all pairs
disp('Calculating (z-normalized) EEG asymmetry for each electrode pair...')
for iPair = 1:size(chanlocs,2)/2+1

    % find pairs using X distance
    for iChan2 = 1:size(chanlocs,2)
        if iChan2 == iPair
            distX(iChan2,:) = NaN;
        else
            distX(iChan2,:) = diff([chanlocs(iPair).X chanlocs(iChan2).X ]);
        end
    end
    [~, match] = min(abs(distX));
    pair(iPair,:) = [iPair match];
    pairLabels(iPair,:) = { sprintf('%s %s', chanlocs(iPair).labels, chanlocs(match).labels) };
    
    % flip if order is not left - left
    if rem(str2double(pairLabels{iPair}(end)),2) ~= 0 % second elec should be even number
        pair(iPair,:) = [match iPair];
        pairLabels(iPair,:) = { sprintf('%s %s', chanlocs(match).labels, chanlocs(iPair).labels) };
    end

    % Z-normalize by correcting for overall alpha power (see Allen et al. 2004 and Smith et al. 2017)
    alpha_left = mean(eeg_features.frequency.alpha(pair(iPair,1),:));
    alpha_right = mean(eeg_features.frequency.alpha(pair(iPair,2),:));
    alpha_left = alpha_left / sum(mean(eeg_features.frequency.alpha,2));
    alpha_right = alpha_right / sum(mean(eeg_features.frequency.alpha,2));

    % Asymmetry
    asy(iPair,:) = log(alpha_left) - log(alpha_right);

end

% eeg_features.frequency.asymmetry_post = log(mean(alpha(post_right,:))) - log(mean(alpha(post_left,:)));

% EEG coherence (only pairs with medium-long distance; see Nunez 2016)
[cohr,f] = mscohere(EEG.data(1,:),EEG.data(2,:),hamming(EEG.srate*2),EEG.srate,[],EEG.srate);
plot(f(f>=0 & f<30), squeeze(cohr(iWin,f>=0 & f<30))); grid on; hold on;



end
